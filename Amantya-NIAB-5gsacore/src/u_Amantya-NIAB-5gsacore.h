
#ifndef _H_u_Amantya_NIAB_5gsacore
#define _H_u_Amantya_NIAB_5gsacore
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file u_Amantya-NIAB-5gsacore.h
 * @brief User SIL header for module Amantya-NIAB-5gsacore
 *

*** Generated by yangdump-sdk 21.10-5

<pre>

    User SIL header
    module Amantya-NIAB-5gsacore
    revision 2022-12-15
    prefix amantya-niab
    namespace http://amantyatech.com/ns/yang/Amantya-NIAB-5gsacore
    organization Amantya Technologies
    Created: 2023-01-30T06:01:42Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        format uh
        indent 4
        module Amantya-NIAB-5gsacore
        output u_Amantya-NIAB-5gsacore.h
        unified true
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "dlq.h"
#include "ncxtypes.h"
#include "op.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "y_Amantya-NIAB-5gsacore.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup sil-Amantya-NIAB-5gsacore Module Amantya-NIAB-5gsacore
 * @ingroup yang-library
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */



/* container /niab */
typedef struct y_amantya_niab_T_niab_ {
    xmlChar *v_gnb;
    xmlChar *v_amf;
    xmlChar *v_smf;
    xmlChar *v_upf;
    xmlChar *v_nrf;
    xmlChar *v_ausf;
    xmlChar *v_nssf;
    xmlChar *v_nef;
    xmlChar *v_pcf;
    xmlChar *v_af;
    xmlChar *v_bsf;
    xmlChar *v_udm;
} y_amantya_niab_T_niab;

/* container /discover-device/input */
typedef struct y_amantya_niab_T_input_ {
    xmlChar *v_ip_add;
    xmlChar *v_port;
    xmlChar *v_user;
    xmlChar *v_password;
    xmlChar *v_name;
    xmlChar *v_type;
    xmlChar *v_serial;
    xmlChar *v_manufacturer;
    xmlChar *v_hw_version;
    xmlChar *v_sw_version;
    boolean v_is_device_added;
} y_amantya_niab_T_input;

/* container /discover-device/output */
typedef struct y_amantya_niab_T_output_ {
} y_amantya_niab_T_output;

/* rpc /discover-device */
typedef struct y_amantya_niab_T_discover_device_ {
    y_amantya_niab_T_input v_input;
    y_amantya_niab_T_output v_output;
} y_amantya_niab_T_discover_device;

/* container /edit-niab/input */
typedef struct y_amantya_niab_T_input_1_ {
    xmlChar *v_oldConfig;
    xmlChar *v_newConfig;
    xmlChar *v_containerType;
} y_amantya_niab_T_input_1;

/* container /edit-niab/output */
typedef struct y_amantya_niab_T_output_1_ {
} y_amantya_niab_T_output_1;

/* rpc /edit-niab */
typedef struct y_amantya_niab_T_edit_niab_ {
    y_amantya_niab_T_input_1 v_input;
    y_amantya_niab_T_output_1 v_output;
} y_amantya_niab_T_edit_niab;

/* container /alarms/input */
typedef struct y_amantya_niab_T_input_2_ {
    xmlChar *v_impactedEntity;
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_input_2;

/* container /alarms/output */
typedef struct y_amantya_niab_T_output_2_ {
} y_amantya_niab_T_output_2;

/* rpc /alarms */
typedef struct y_amantya_niab_T_alarms_ {
    y_amantya_niab_T_input_2 v_input;
    y_amantya_niab_T_output_2 v_output;
} y_amantya_niab_T_alarms;

/* container /change-contanier-state/input */
typedef struct y_amantya_niab_T_input_3_ {
    xmlChar *v_containerType;
    xmlChar *v_containerState;
} y_amantya_niab_T_input_3;

/* container /change-contanier-state/output */
typedef struct y_amantya_niab_T_output_3_ {
} y_amantya_niab_T_output_3;

/* rpc /change-contanier-state */
typedef struct y_amantya_niab_T_change_contanier_state_ {
    y_amantya_niab_T_input_3 v_input;
    y_amantya_niab_T_output_3 v_output;
} y_amantya_niab_T_change_contanier_state;

/* notification /updateConfigurtion */
typedef struct y_amantya_niab_T_updateConfigurtion_ {
    xmlChar *v_fileUpdated;
} y_amantya_niab_T_updateConfigurtion;

/* notification /register-device */
typedef struct y_amantya_niab_T_register_device_ {
    xmlChar *v_ip_add;
    xmlChar *v_port;
    xmlChar *v_user;
    xmlChar *v_password;
    xmlChar *v_name;
    xmlChar *v_type;
    xmlChar *v_serial;
    xmlChar *v_manufacturer;
    xmlChar *v_hw_version;
    xmlChar *v_sw_version;
    boolean v_is_device_added;
} y_amantya_niab_T_register_device;

/* notification /niab_containers_amf */
typedef struct y_amantya_niab_T_niab_containers_amf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_amf;

/* notification /niab_containers_gnb */
typedef struct y_amantya_niab_T_niab_containers_gnb_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_gnb;

/* notification /niab_containers_upf */
typedef struct y_amantya_niab_T_niab_containers_upf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_upf;

/* notification /niab_containers_smf */
typedef struct y_amantya_niab_T_niab_containers_smf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_smf;

/* notification /niab_containers_nrf */
typedef struct y_amantya_niab_T_niab_containers_nrf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_nrf;

/* notification /niab_containers_ausf */
typedef struct y_amantya_niab_T_niab_containers_ausf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_ausf;

/* notification /niab_containers_nssf */
typedef struct y_amantya_niab_T_niab_containers_nssf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_nssf;

/* notification /niab_containers_nef */
typedef struct y_amantya_niab_T_niab_containers_nef_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_nef;

/* notification /niab_containers_pcf */
typedef struct y_amantya_niab_T_niab_containers_pcf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_pcf;

/* notification /niab_containers_af */
typedef struct y_amantya_niab_T_niab_containers_af_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_af;

/* notification /niab_containers_bsf */
typedef struct y_amantya_niab_T_niab_containers_bsf_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_bsf;

/* notification /niab_containers_udm */
typedef struct y_amantya_niab_T_niab_containers_udm_ {
    xmlChar *v_changedState;
    xmlChar *v_alarmSource;
    xmlChar *v_timeRaised;
    xmlChar *v_severity;
    xmlChar *v_description;
    boolean v_clearAlarm;
    xmlChar *v_alarmType;
} y_amantya_niab_T_niab_containers_udm;


/**
 * @brief Get database object callback for leaf gnb (getcb_fn2_t)\n
 * Path: leaf /niab/gnb\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_gnb_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf amf (getcb_fn2_t)\n
 * Path: leaf /niab/amf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_amf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf smf (getcb_fn2_t)\n
 * Path: leaf /niab/smf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_smf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf upf (getcb_fn2_t)\n
 * Path: leaf /niab/upf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_upf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf nrf (getcb_fn2_t)\n
 * Path: leaf /niab/nrf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_nrf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf ausf (getcb_fn2_t)\n
 * Path: leaf /niab/ausf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_ausf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf nssf (getcb_fn2_t)\n
 * Path: leaf /niab/nssf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_nssf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf nef (getcb_fn2_t)\n
 * Path: leaf /niab/nef\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_nef_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf pcf (getcb_fn2_t)\n
 * Path: leaf /niab/pcf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_pcf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf af (getcb_fn2_t)\n
 * Path: leaf /niab/af\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_af_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf bsf (getcb_fn2_t)\n
 * Path: leaf /niab/bsf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_bsf_get (
    getcb_get2_t *get2cb);


/**
 * @brief Get database object callback for leaf udm (getcb_fn2_t)\n
 * Path: leaf /niab/udm\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
extern status_t u_amantya_niab_udm_get (
    getcb_get2_t *get2cb);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /niab
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
extern status_t u_amantya_niab_niab_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval);


/**
 * @brief Validation phase callback for "<discover-device>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_discover_device_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Invocation phase callback for "<discover-device>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_discover_device_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Validation phase callback for "<edit-niab>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_edit_niab_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Invocation phase callback for "<edit-niab>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_edit_niab_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Validation phase callback for "<alarms>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_alarms_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Invocation phase callback for "<alarms>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_alarms_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Validation phase callback for "<change-contanier-state>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_change_contanier_state_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Invocation phase callback for "<change-contanier-state>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_amantya_niab_change_contanier_state_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode);


/**
 * @brief Send a "<updateConfigurtion>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_updateConfigurtion_send (
    const xmlChar *v_fileUpdated);


/**
 * @brief Send a "<register-device>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_register_device_send (
    const xmlChar *v_ip_add,
    const xmlChar *v_port,
    const xmlChar *v_user,
    const xmlChar *v_password,
    const xmlChar *v_name,
    const xmlChar *v_type,
    const xmlChar *v_serial,
    const xmlChar *v_manufacturer,
    const xmlChar *v_hw_version,
    const xmlChar *v_sw_version,
    boolean v_is_device_added);


/**
 * @brief Send a "<niab_containers_amf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_amf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_gnb>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_gnb_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_upf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_upf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_smf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_smf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_nrf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_nrf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_ausf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_ausf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_nssf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_nssf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_nef>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_nef_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_pcf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_pcf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_af>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_af_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_bsf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_bsf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Send a "<niab_containers_udm>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
extern void u_amantya_niab_niab_containers_udm_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType);


/**
 * @brief Phase 1: Initialize the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
extern status_t u_Amantya_NIAB_5gsacore_init (
    const xmlChar *modname,
    const xmlChar *revision);


/**
 * @brief Phase 2: Initialize the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
extern status_t u_Amantya_NIAB_5gsacore_init2 (void);


/**
 * @brief Cleanup the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
extern void u_Amantya_NIAB_5gsacore_cleanup (void);


 /** @} */

#ifdef __cplusplus
} /* end extern 'C' */
#endif

#endif
