
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file u_Amantya-NIAB-5gsacore.c
 * @brief User SIL module for module Amantya-NIAB-5gsacore
 *

*** Generated by yangdump-sdk 21.10-5

<pre>

    User SIL module
    module Amantya-NIAB-5gsacore
    revision 2022-12-15
    prefix amantya-niab
    namespace http://amantyatech.com/ns/yang/Amantya-NIAB-5gsacore
    organization Amantya Technologies
    Created: 2023-01-30T06:01:42Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        format uc
        indent 4
        module Amantya-NIAB-5gsacore
        output u_Amantya-NIAB-5gsacore.c
        unified true

  Short Name Mappings
    af = /niab/af
    alarmSource = /alarms/input/alarmSource
    alarmSource_1 = /niab_containers_amf/alarmSource
    alarmSource_10 = /niab_containers_af/alarmSource
    alarmSource_11 = /niab_containers_bsf/alarmSource
    alarmSource_12 = /niab_containers_udm/alarmSource
    alarmSource_2 = /niab_containers_gnb/alarmSource
    alarmSource_3 = /niab_containers_upf/alarmSource
    alarmSource_4 = /niab_containers_smf/alarmSource
    alarmSource_5 = /niab_containers_nrf/alarmSource
    alarmSource_6 = /niab_containers_ausf/alarmSource
    alarmSource_7 = /niab_containers_nssf/alarmSource
    alarmSource_8 = /niab_containers_nef/alarmSource
    alarmSource_9 = /niab_containers_pcf/alarmSource
    alarmType = /alarms/input/alarmType
    alarmType_1 = /niab_containers_amf/alarmType
    alarmType_10 = /niab_containers_af/alarmType
    alarmType_11 = /niab_containers_bsf/alarmType
    alarmType_12 = /niab_containers_udm/alarmType
    alarmType_2 = /niab_containers_gnb/alarmType
    alarmType_3 = /niab_containers_upf/alarmType
    alarmType_4 = /niab_containers_smf/alarmType
    alarmType_5 = /niab_containers_nrf/alarmType
    alarmType_6 = /niab_containers_ausf/alarmType
    alarmType_7 = /niab_containers_nssf/alarmType
    alarmType_8 = /niab_containers_nef/alarmType
    alarmType_9 = /niab_containers_pcf/alarmType
    alarms = /alarms
    amf = /niab/amf
    ausf = /niab/ausf
    bsf = /niab/bsf
    change_contanier_state = /change-contanier-state
    changedState = /alarms/input/changedState
    changedState_1 = /niab_containers_amf/changedState
    changedState_10 = /niab_containers_af/changedState
    changedState_11 = /niab_containers_bsf/changedState
    changedState_12 = /niab_containers_udm/changedState
    changedState_2 = /niab_containers_gnb/changedState
    changedState_3 = /niab_containers_upf/changedState
    changedState_4 = /niab_containers_smf/changedState
    changedState_5 = /niab_containers_nrf/changedState
    changedState_6 = /niab_containers_ausf/changedState
    changedState_7 = /niab_containers_nssf/changedState
    changedState_8 = /niab_containers_nef/changedState
    changedState_9 = /niab_containers_pcf/changedState
    clearAlarm = /alarms/input/clearAlarm
    clearAlarm_1 = /niab_containers_amf/clearAlarm
    clearAlarm_10 = /niab_containers_af/clearAlarm
    clearAlarm_11 = /niab_containers_bsf/clearAlarm
    clearAlarm_12 = /niab_containers_udm/clearAlarm
    clearAlarm_2 = /niab_containers_gnb/clearAlarm
    clearAlarm_3 = /niab_containers_upf/clearAlarm
    clearAlarm_4 = /niab_containers_smf/clearAlarm
    clearAlarm_5 = /niab_containers_nrf/clearAlarm
    clearAlarm_6 = /niab_containers_ausf/clearAlarm
    clearAlarm_7 = /niab_containers_nssf/clearAlarm
    clearAlarm_8 = /niab_containers_nef/clearAlarm
    clearAlarm_9 = /niab_containers_pcf/clearAlarm
    containerState = /change-contanier-state/input/containerState
    containerType = /edit-niab/input/containerType
    containerType_1 = /change-contanier-state/input/containerType
    description = /alarms/input/description
    description_1 = /niab_containers_amf/description
    description_10 = /niab_containers_af/description
    description_11 = /niab_containers_bsf/description
    description_12 = /niab_containers_udm/description
    description_2 = /niab_containers_gnb/description
    description_3 = /niab_containers_upf/description
    description_4 = /niab_containers_smf/description
    description_5 = /niab_containers_nrf/description
    description_6 = /niab_containers_ausf/description
    description_7 = /niab_containers_nssf/description
    description_8 = /niab_containers_nef/description
    description_9 = /niab_containers_pcf/description
    discover_device = /discover-device
    edit_niab = /edit-niab
    fileUpdated = /updateConfigurtion/fileUpdated
    gnb = /niab/gnb
    hw_version = /discover-device/input/hw_version
    hw_version_1 = /register-device/hw_version
    impactedEntity = /alarms/input/impactedEntity
    input = /discover-device/input
    input_1 = /edit-niab/input
    input_2 = /alarms/input
    input_3 = /change-contanier-state/input
    ip_add = /discover-device/input/ip_add
    ip_add_1 = /register-device/ip_add
    is_device_added = /discover-device/input/is_device_added
    is_device_added_1 = /register-device/is_device_added
    manufacturer = /discover-device/input/manufacturer
    manufacturer_1 = /register-device/manufacturer
    name = /discover-device/input/name
    name_1 = /register-device/name
    nef = /niab/nef
    newConfig = /edit-niab/input/newConfig
    niab = /niab
    niab_containers_af = /niab_containers_af
    niab_containers_amf = /niab_containers_amf
    niab_containers_ausf = /niab_containers_ausf
    niab_containers_bsf = /niab_containers_bsf
    niab_containers_gnb = /niab_containers_gnb
    niab_containers_nef = /niab_containers_nef
    niab_containers_nrf = /niab_containers_nrf
    niab_containers_nssf = /niab_containers_nssf
    niab_containers_pcf = /niab_containers_pcf
    niab_containers_smf = /niab_containers_smf
    niab_containers_udm = /niab_containers_udm
    niab_containers_upf = /niab_containers_upf
    nrf = /niab/nrf
    nssf = /niab/nssf
    oldConfig = /edit-niab/input/oldConfig
    output = /discover-device/output
    output_1 = /edit-niab/output
    output_2 = /alarms/output
    output_3 = /change-contanier-state/output
    password = /discover-device/input/password
    password_1 = /register-device/password
    pcf = /niab/pcf
    port = /discover-device/input/port
    port_1 = /register-device/port
    register_device = /register-device
    serial = /discover-device/input/serial
    serial_1 = /register-device/serial
    severity = /alarms/input/severity
    severity_1 = /niab_containers_amf/severity
    severity_10 = /niab_containers_af/severity
    severity_11 = /niab_containers_bsf/severity
    severity_12 = /niab_containers_udm/severity
    severity_2 = /niab_containers_gnb/severity
    severity_3 = /niab_containers_upf/severity
    severity_4 = /niab_containers_smf/severity
    severity_5 = /niab_containers_nrf/severity
    severity_6 = /niab_containers_ausf/severity
    severity_7 = /niab_containers_nssf/severity
    severity_8 = /niab_containers_nef/severity
    severity_9 = /niab_containers_pcf/severity
    smf = /niab/smf
    sw_version = /discover-device/input/sw_version
    sw_version_1 = /register-device/sw_version
    timeRaised = /alarms/input/timeRaised
    timeRaised_1 = /niab_containers_amf/timeRaised
    timeRaised_10 = /niab_containers_af/timeRaised
    timeRaised_11 = /niab_containers_bsf/timeRaised
    timeRaised_12 = /niab_containers_udm/timeRaised
    timeRaised_2 = /niab_containers_gnb/timeRaised
    timeRaised_3 = /niab_containers_upf/timeRaised
    timeRaised_4 = /niab_containers_smf/timeRaised
    timeRaised_5 = /niab_containers_nrf/timeRaised
    timeRaised_6 = /niab_containers_ausf/timeRaised
    timeRaised_7 = /niab_containers_nssf/timeRaised
    timeRaised_8 = /niab_containers_nef/timeRaised
    timeRaised_9 = /niab_containers_pcf/timeRaised
    type = /discover-device/input/type
    type_1 = /register-device/type
    udm = /niab/udm
    updateConfigurtion = /updateConfigurtion
    upf = /niab/upf
    user = /discover-device/input/user
    user_1 = /register-device/user
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_cfg.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_util.h"
#include "xml_val.h"
#include "u_Amantya-NIAB-5gsacore.h"
#include "y_Amantya-NIAB-5gsacore.h"

#include </usr/lib/jvm/jdk-18/include/jni.h>
#include </usr/lib/jvm/jdk-18/include/linux/jni_md.h>
#include <string.h>
#include <stdio.h>


/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup sil-Amantya-NIAB-5gsacore Module Amantya-NIAB-5gsacore
 * @ingroup yang-library
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */


static obj_template_t *updateConfigurtion_obj;
static obj_template_t *register_device_obj;
static obj_template_t *niab_containers_amf_obj;
static obj_template_t *niab_containers_gnb_obj;
static obj_template_t *niab_containers_upf_obj;
static obj_template_t *niab_containers_smf_obj;
static obj_template_t *niab_containers_nrf_obj;
static obj_template_t *niab_containers_ausf_obj;
static obj_template_t *niab_containers_nssf_obj;
static obj_template_t *niab_containers_nef_obj;
static obj_template_t *niab_containers_pcf_obj;
static obj_template_t *niab_containers_af_obj;
static obj_template_t *niab_containers_bsf_obj;
static obj_template_t *niab_containers_udm_obj;

/* put your static variables here */


/**
 * @brief Get database object callback for leaf gnb (getcb_fn2_t)\n
 * Path: leaf /niab/gnb\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_gnb_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_gnb_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */

    const xmlChar *v_gnb = (const xmlChar *) 0;

    /* add gnb to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_gnb,
        v_gnb,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_gnb_get */



/**
 * @brief Get database object callback for leaf amf (getcb_fn2_t)\n
 * Path: leaf /niab/amf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_amf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_amf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_amf = 0;

    /* add amf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_amf,
        v_amf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_amf_get */



/**
 * @brief Get database object callback for leaf smf (getcb_fn2_t)\n
 * Path: leaf /niab/smf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_smf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_smf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_smf = 0;

    /* add smf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_smf,
        v_smf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_smf_get */



/**
 * @brief Get database object callback for leaf upf (getcb_fn2_t)\n
 * Path: leaf /niab/upf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_upf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_upf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_upf = 0;

    /* add upf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_upf,
        v_upf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_upf_get */



/**
 * @brief Get database object callback for leaf nrf (getcb_fn2_t)\n
 * Path: leaf /niab/nrf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_nrf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_nrf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_nrf = 0;

    /* add nrf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_nrf,
        v_nrf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_nrf_get */



/**
 * @brief Get database object callback for leaf ausf (getcb_fn2_t)\n
 * Path: leaf /niab/ausf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_ausf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_ausf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_ausf = 0;

    /* add ausf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_ausf,
        v_ausf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_ausf_get */



/**
 * @brief Get database object callback for leaf nssf (getcb_fn2_t)\n
 * Path: leaf /niab/nssf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_nssf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_nssf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_nssf = 0;

    /* add nssf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_nssf,
        v_nssf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_nssf_get */



/**
 * @brief Get database object callback for leaf nef (getcb_fn2_t)\n
 * Path: leaf /niab/nef\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_nef_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_nef_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_nef = 0;

    /* add nef to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_nef,
        v_nef,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_nef_get */



/**
 * @brief Get database object callback for leaf pcf (getcb_fn2_t)\n
 * Path: leaf /niab/pcf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_pcf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_pcf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_pcf = 0;

    /* add pcf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_pcf,
        v_pcf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_pcf_get */



/**
 * @brief Get database object callback for leaf af (getcb_fn2_t)\n
 * Path: leaf /niab/af\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_af_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_af_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_af = 0;

    /* add af to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_af,
        v_af,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_af_get */



/**
 * @brief Get database object callback for leaf bsf (getcb_fn2_t)\n
 * Path: leaf /niab/bsf\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_bsf_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_bsf_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_bsf = 0;

    /* add bsf to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_bsf,
        v_bsf,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_bsf_get */



/**
 * @brief Get database object callback for leaf udm (getcb_fn2_t)\n
 * Path: leaf /niab/udm\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
status_t u_amantya_niab_udm_get (
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_udm_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_udm = 0;

    /* add udm to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_udm,
        v_udm,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_amantya_niab_udm_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /niab
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
status_t u_amantya_niab_niab_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_amantya_niab_niab_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_amantya_niab_niab_edit */


/**
 * @brief Validation phase callback for "<discover-device>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_discover_device_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    if (LOGDEBUG) {
        log_debug("\nStart SIL validate rpc <discover-device> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_ip_add_val = NULL;
    const xmlChar *v_ip_add = NULL;

    val_value_t *v_port_val = NULL;
    const xmlChar *v_port = NULL;

    val_value_t *v_user_val = NULL;
    const xmlChar *v_user = NULL;

    val_value_t *v_password_val = NULL;
    const xmlChar *v_password = NULL;

    val_value_t *v_name_val = NULL;
    const xmlChar *v_name = NULL;

    val_value_t *v_type_val = NULL;
    const xmlChar *v_type = NULL;

    val_value_t *v_serial_val = NULL;
    const xmlChar *v_serial = NULL;

    val_value_t *v_manufacturer_val = NULL;
    const xmlChar *v_manufacturer = NULL;

    val_value_t *v_hw_version_val = NULL;
    const xmlChar *v_hw_version = NULL;

    val_value_t *v_sw_version_val = NULL;
    const xmlChar *v_sw_version = NULL;

    val_value_t *v_is_device_added_val = NULL;
    boolean v_is_device_added = false;

    /* RPC Input: ip_add */
    v_ip_add_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_ip_add);
    if (v_ip_add_val) {
        v_ip_add = VAL_STRING(v_ip_add_val);
        (void)v_ip_add;  /* remove this line if variable used */
    }

    /* RPC Input: port */
    v_port_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_port);
    if (v_port_val) {
        v_port = VAL_STRING(v_port_val);
        (void)v_port;  /* remove this line if variable used */
    }

    /* RPC Input: user */
    v_user_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_user);
    if (v_user_val) {
        v_user = VAL_STRING(v_user_val);
        (void)v_user;  /* remove this line if variable used */
    }

    /* RPC Input: password */
    v_password_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_password);
    if (v_password_val) {
        v_password = VAL_STRING(v_password_val);
        (void)v_password;  /* remove this line if variable used */
    }

    /* RPC Input: name */
    v_name_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_name);
    if (v_name_val) {
        v_name = VAL_STRING(v_name_val);
        (void)v_name;  /* remove this line if variable used */
    }

    /* RPC Input: type */
    v_type_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_type);
    if (v_type_val) {
        v_type = VAL_STRING(v_type_val);
        (void)v_type;  /* remove this line if variable used */
    }

    /* RPC Input: serial */
    v_serial_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_serial);
    if (v_serial_val) {
        v_serial = VAL_STRING(v_serial_val);
        (void)v_serial;  /* remove this line if variable used */
    }

    /* RPC Input: manufacturer */
    v_manufacturer_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_manufacturer);
    if (v_manufacturer_val) {
        v_manufacturer = VAL_STRING(v_manufacturer_val);
        (void)v_manufacturer;  /* remove this line if variable used */
    }

    /* RPC Input: hw_version */
    v_hw_version_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_hw_version);
    if (v_hw_version_val) {
        v_hw_version = VAL_STRING(v_hw_version_val);
        (void)v_hw_version;  /* remove this line if variable used */
    }

    /* RPC Input: sw_version */
    v_sw_version_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_sw_version);
    if (v_sw_version_val) {
        v_sw_version = VAL_STRING(v_sw_version_val);
        (void)v_sw_version;  /* remove this line if variable used */
    }

    /* RPC Input: is_device_added */
    v_is_device_added_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_is_device_added);
    if (v_is_device_added_val) {
        v_is_device_added = VAL_BOOL(v_is_device_added_val);
        (void)v_is_device_added;  /* remove this line if variable used */
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* u_amantya_niab_discover_device_validate */


/**
 * @brief Invocation phase callback for "<discover-device>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_discover_device_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nStart SIL invoke rpc <discover-device> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_ip_add_val = NULL;
    const xmlChar *v_ip_add = NULL;

    val_value_t *v_port_val = NULL;
    const xmlChar *v_port = NULL;

    val_value_t *v_user_val = NULL;
    const xmlChar *v_user = NULL;

    val_value_t *v_password_val = NULL;
    const xmlChar *v_password = NULL;

    val_value_t *v_name_val = NULL;
    const xmlChar *v_name = NULL;

    val_value_t *v_type_val = NULL;
    const xmlChar *v_type = NULL;

    val_value_t *v_serial_val = NULL;
    const xmlChar *v_serial = NULL;

    val_value_t *v_manufacturer_val = NULL;
    const xmlChar *v_manufacturer = NULL;

    val_value_t *v_hw_version_val = NULL;
    const xmlChar *v_hw_version = NULL;

    val_value_t *v_sw_version_val = NULL;
    const xmlChar *v_sw_version = NULL;

    val_value_t *v_is_device_added_val = NULL;
    boolean v_is_device_added = false;

    /* RPC Input: ip_add */
    v_ip_add_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_ip_add);
    if (v_ip_add_val) {
        v_ip_add = VAL_STRING(v_ip_add_val);
        (void)v_ip_add;  /* remove this line if variable used */
    }

    /* RPC Input: port */
    v_port_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_port);
    if (v_port_val) {
        v_port = VAL_STRING(v_port_val);
        (void)v_port;  /* remove this line if variable used */
    }

    /* RPC Input: user */
    v_user_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_user);
    if (v_user_val) {
        v_user = VAL_STRING(v_user_val);
        (void)v_user;  /* remove this line if variable used */
    }

    /* RPC Input: password */
    v_password_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_password);
    if (v_password_val) {
        v_password = VAL_STRING(v_password_val);
        (void)v_password;  /* remove this line if variable used */
    }

    /* RPC Input: name */
    v_name_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_name);
    if (v_name_val) {
        v_name = VAL_STRING(v_name_val);
        (void)v_name;  /* remove this line if variable used */
    }

    /* RPC Input: type */
    v_type_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_type);
    if (v_type_val) {
        v_type = VAL_STRING(v_type_val);
        (void)v_type;  /* remove this line if variable used */
    }

    /* RPC Input: serial */
    v_serial_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_serial);
    if (v_serial_val) {
        v_serial = VAL_STRING(v_serial_val);
        (void)v_serial;  /* remove this line if variable used */
    }

    /* RPC Input: manufacturer */
    v_manufacturer_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_manufacturer);
    if (v_manufacturer_val) {
        v_manufacturer = VAL_STRING(v_manufacturer_val);
        (void)v_manufacturer;  /* remove this line if variable used */
    }

    /* RPC Input: hw_version */
    v_hw_version_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_hw_version);
    if (v_hw_version_val) {
        v_hw_version = VAL_STRING(v_hw_version_val);
        (void)v_hw_version;  /* remove this line if variable used */
    }

    /* RPC Input: sw_version */
    v_sw_version_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_sw_version);
    if (v_sw_version_val) {
        v_sw_version = VAL_STRING(v_sw_version_val);
        (void)v_sw_version;  /* remove this line if variable used */
    }

    /* RPC Input: is_device_added */
    v_is_device_added_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_is_device_added);
    if (v_is_device_added_val) {
        v_is_device_added = VAL_BOOL(v_is_device_added_val);
        (void)v_is_device_added;  /* remove this line if variable used */
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
     /*==============================================*/

     /*============================================================================================*/
    // Compile Java Class
    system("/usr/lib/jvm/java-11-openjdk-amd64/bin/javac /home/amantya/modules/Java_Files/ReadWriteFiles.java");
    log_debug("\nJAVA FILES COMPILATION IS SUCCESSFUL\n");

    /* get the real value from the system somehow */

    JavaVM *vm;
	JNIEnv *env;
	JavaVMInitArgs vm_args;
	jint res1;
	JavaVMAttachArgs args;
	jclass cls;
	jint sVal;
	jmethodID mid;
	jstring jstr;
	jobjectArray main_args;
	jobject obj1;
	JavaVMOption options;
	options.optionString = "-Djava.class.path=/home/amantya/modules/Java_Files/"; // Path to the java source code
	vm_args.version = JNI_VERSION_1_8;
	vm_args.nOptions = 1;
	vm_args.options = &options;

	res1 = JNI_CreateJavaVM(&vm, (void **)&env, &vm_args);
	if(res1 != JNI_OK)
	{
		res1 = JNI_GetCreatedJavaVMs(&vm, 1, NULL);
                res1 = (*vm)->AttachCurrentThread(vm, (void **)&env, NULL);

		printf("\nFailed to create Java VM\n");

              (*vm)->AttachCurrentThread(vm, (void**)&env, &args);
             }
	cls = (*env)->FindClass(env, "ReadWriteFiles");
	if (cls == NULL)
	{
		printf("\n FAILED to FIND ReadWriteFiles class \n");
		return 1;
	}

	//------------------------------Calling a void OBJECT METHOD with INTEGER Arguments -----------------------------------------

	jmethodID constructor = (*env)->GetMethodID(env, cls, "<init>", "()V");
	jobject jobjDet;
	if (constructor != NULL)
	{
		jobjDet = (*env)->NewObject(env, cls, constructor, "");
	}

	//-------------Calling a int OBJECT METHOD with STRING Arguments and STRING Return -----------------------------

	jmethodID mid6 = (*env)->GetMethodID(env, cls, "updateDeviceDetails", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)V");
  if(mid6 == NULL) {
     printf("\n updateDeviceDetails METHOD IS NULL \n");
      }
    jstring fileNamefordd = (*env)->NewStringUTF(env, "/home/amantya/5gDevices/devices.txt");
     jstring DEVICE_IP = (*env)->NewStringUTF(env, v_ip_add);
     jstring PORT = (*env)->NewStringUTF(env, v_port);
     jstring USER_NAME = (*env)->NewStringUTF(env, v_user);
     jstring PASSWORD = (*env)->NewStringUTF(env, v_password);
      jstring DEVICE_NAME = (*env)->NewStringUTF(env, v_name);
      jstring DEVICE_TYPE = (*env)->NewStringUTF(env, v_type);
     jstring SERIAL = (*env)->NewStringUTF(env, v_serial);
     jstring MANUFACTURER = (*env)->NewStringUTF(env, v_manufacturer);
     jstring  HARDWARE_VERSION = (*env)->NewStringUTF(env, v_hw_version);
     jstring SOFTWARE_VERSION = (*env)->NewStringUTF(env, v_sw_version);
     jboolean DEVICE_ADDED = v_is_device_added;

    // jstring DEVICE_ADDED = (*env)->NewStringUTF(env, v_is_device_added);
    (*env)->CallVoidMethod(env, jobjDet, mid6, fileNamefordd, DEVICE_IP, PORT, USER_NAME, PASSWORD, DEVICE_NAME, DEVICE_TYPE, SERIAL, MANUFACTURER, HARDWARE_VERSION, SOFTWARE_VERSION, DEVICE_ADDED);

	 res1 = (*vm)->DetachCurrentThread(vm);

//	int n = (*vm)->DestroyJavaVM(vm);

   // const xmlChar *v_gnb = (const xmlChar *) rStr;

   /*==================================================================================================*/


     /*===================================================*/
    /* No output nodes expected */

    return res;

} /* u_amantya_niab_discover_device_invoke */


/**
 * @brief Validation phase callback for "<edit-niab>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_edit_niab_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    if (LOGDEBUG) {
        log_debug("\nStart SIL validate rpc <edit-niab> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_oldConfig_val = NULL;
    const xmlChar *v_oldConfig = NULL;

    val_value_t *v_newConfig_val = NULL;
    const xmlChar *v_newConfig = NULL;

    val_value_t *v_containerType_val = NULL;
    const xmlChar *v_containerType = NULL;

    /* RPC Input: oldConfig */
    v_oldConfig_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_oldConfig);
    if (v_oldConfig_val) {
        v_oldConfig = VAL_STRING(v_oldConfig_val);
        (void)v_oldConfig;  /* remove this line if variable used */
    }

    /* RPC Input: newConfig */
    v_newConfig_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_newConfig);
    if (v_newConfig_val) {
        v_newConfig = VAL_STRING(v_newConfig_val);
        (void)v_newConfig;  /* remove this line if variable used */
    }

    /* RPC Input: containerType */
    v_containerType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerType);
    if (v_containerType_val) {
        v_containerType = VAL_STRING(v_containerType_val);
        (void)v_containerType;  /* remove this line if variable used */
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* u_amantya_niab_edit_niab_validate */


/**
 * @brief Invocation phase callback for "<edit-niab>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_edit_niab_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nStart SIL invoke rpc <edit-niab> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_oldConfig_val = NULL;
    const xmlChar *v_oldConfig = NULL;

    val_value_t *v_newConfig_val = NULL;
    const xmlChar *v_newConfig = NULL;

    val_value_t *v_containerType_val = NULL;
    const xmlChar *v_containerType = NULL;

    /* RPC Input: oldConfig */
    v_oldConfig_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_oldConfig);
    if (v_oldConfig_val) {
        v_oldConfig = VAL_STRING(v_oldConfig_val);
        (void)v_oldConfig;  /* remove this line if variable used */
    }

    /* RPC Input: newConfig */
    v_newConfig_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_newConfig);
    if (v_newConfig_val) {
        v_newConfig = VAL_STRING(v_newConfig_val);
        (void)v_newConfig;  /* remove this line if variable used */
    }

    /* RPC Input: containerType */
    v_containerType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerType);
    if (v_containerType_val) {
        v_containerType = VAL_STRING(v_containerType_val);
        (void)v_containerType;  /* remove this line if variable used */
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */

    /* No output nodes expected */

    return res;

} /* u_amantya_niab_edit_niab_invoke */


/**
 * @brief Validation phase callback for "<alarms>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_alarms_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    if (LOGDEBUG) {
        log_debug("\nStart SIL validate rpc <alarms> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_impactedEntity_val = NULL;
    const xmlChar *v_impactedEntity = NULL;

    val_value_t *v_changedState_val = NULL;
    const xmlChar *v_changedState = NULL;

    val_value_t *v_alarmSource_val = NULL;
    const xmlChar *v_alarmSource = NULL;

    val_value_t *v_timeRaised_val = NULL;
    const xmlChar *v_timeRaised = NULL;

    val_value_t *v_severity_val = NULL;
    const xmlChar *v_severity = NULL;

    val_value_t *v_description_val = NULL;
    const xmlChar *v_description = NULL;

    val_value_t *v_clearAlarm_val = NULL;
    boolean v_clearAlarm = false;

    val_value_t *v_alarmType_val = NULL;
    const xmlChar *v_alarmType = NULL;

    /* RPC Input: impactedEntity */
    v_impactedEntity_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_impactedEntity);
    if (v_impactedEntity_val) {
        v_impactedEntity = VAL_STRING(v_impactedEntity_val);
        (void)v_impactedEntity;  /* remove this line if variable used */
    }

    /* RPC Input: changedState */
    v_changedState_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState);
    if (v_changedState_val) {
        v_changedState = VAL_STRING(v_changedState_val);
        (void)v_changedState;  /* remove this line if variable used */
    }

    /* RPC Input: alarmSource */
    v_alarmSource_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource);
    if (v_alarmSource_val) {
        v_alarmSource = VAL_STRING(v_alarmSource_val);
        (void)v_alarmSource;  /* remove this line if variable used */
    }

    /* RPC Input: timeRaised */
    v_timeRaised_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised);
    if (v_timeRaised_val) {
        v_timeRaised = VAL_STRING(v_timeRaised_val);
        (void)v_timeRaised;  /* remove this line if variable used */
    }

    /* RPC Input: severity */
    v_severity_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity);
    if (v_severity_val) {
        v_severity = VAL_ENUM_NAME(v_severity_val);
        (void)v_severity;  /* remove this line if variable used */
    }

    /* RPC Input: description */
    v_description_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description);
    if (v_description_val) {
        v_description = VAL_STRING(v_description_val);
        (void)v_description;  /* remove this line if variable used */
    }

    /* RPC Input: clearAlarm */
    v_clearAlarm_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm);
    if (v_clearAlarm_val) {
        v_clearAlarm = VAL_BOOL(v_clearAlarm_val);
        (void)v_clearAlarm;  /* remove this line if variable used */
    }

    /* RPC Input: alarmType */
    v_alarmType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType);
    if (v_alarmType_val) {
        v_alarmType = VAL_STRING(v_alarmType_val);
        (void)v_alarmType;  /* remove this line if variable used */
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* u_amantya_niab_alarms_validate */


/**
 * @brief Invocation phase callback for "<alarms>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_alarms_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nStart SIL invoke rpc <alarms> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_impactedEntity_val = NULL;
    const xmlChar *v_impactedEntity = NULL;

    val_value_t *v_changedState_val = NULL;
    const xmlChar *v_changedState = NULL;

    val_value_t *v_alarmSource_val = NULL;
    const xmlChar *v_alarmSource = NULL;

    val_value_t *v_timeRaised_val = NULL;
    const xmlChar *v_timeRaised = NULL;

    val_value_t *v_severity_val = NULL;
    const xmlChar *v_severity = NULL;

    val_value_t *v_description_val = NULL;
    const xmlChar *v_description = NULL;

    val_value_t *v_clearAlarm_val = NULL;
    boolean v_clearAlarm = false;

    val_value_t *v_alarmType_val = NULL;
    const xmlChar *v_alarmType = NULL;

    /* RPC Input: impactedEntity */
    v_impactedEntity_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_impactedEntity);
    if (v_impactedEntity_val) {
        v_impactedEntity = VAL_STRING(v_impactedEntity_val);
        (void)v_impactedEntity;  /* remove this line if variable used */
    }

    /* RPC Input: changedState */
    v_changedState_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState);
    if (v_changedState_val) {
        v_changedState = VAL_STRING(v_changedState_val);
        (void)v_changedState;  /* remove this line if variable used */
    }

    /* RPC Input: alarmSource */
    v_alarmSource_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource);
    if (v_alarmSource_val) {
        v_alarmSource = VAL_STRING(v_alarmSource_val);
        (void)v_alarmSource;  /* remove this line if variable used */
    }

    /* RPC Input: timeRaised */
    v_timeRaised_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised);
    if (v_timeRaised_val) {
        v_timeRaised = VAL_STRING(v_timeRaised_val);
        (void)v_timeRaised;  /* remove this line if variable used */
    }

    /* RPC Input: severity */
    v_severity_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity);
    if (v_severity_val) {
        v_severity = VAL_ENUM_NAME(v_severity_val);
        (void)v_severity;  /* remove this line if variable used */
    }

    /* RPC Input: description */
    v_description_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description);
    if (v_description_val) {
        v_description = VAL_STRING(v_description_val);
        (void)v_description;  /* remove this line if variable used */
    }

    /* RPC Input: clearAlarm */
    v_clearAlarm_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm);
    if (v_clearAlarm_val) {
        v_clearAlarm = VAL_BOOL(v_clearAlarm_val);
        (void)v_clearAlarm;  /* remove this line if variable used */
    }

    /* RPC Input: alarmType */
    v_alarmType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType);
    if (v_alarmType_val) {
        v_alarmType = VAL_STRING(v_alarmType_val);
        (void)v_alarmType;  /* remove this line if variable used */
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */

    /* No output nodes expected */

    return res;

} /* u_amantya_niab_alarms_invoke */


/**
 * @brief Validation phase callback for "<change-contanier-state>" operation. (agt_rpc_method_t)
 *
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_change_contanier_state_validate (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    if (LOGDEBUG) {
        log_debug("\nStart SIL validate rpc <change-contanier-state> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_containerType_val = NULL;
    const xmlChar *v_containerType = NULL;

    val_value_t *v_containerState_val = NULL;
    const xmlChar *v_containerState = NULL;

    /* RPC Input: containerType */
    v_containerType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerType);
    if (v_containerType_val) {
        v_containerType = VAL_STRING(v_containerType_val);
        (void)v_containerType;  /* remove this line if variable used */
    }

    /* RPC Input: containerState */
    v_containerState_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerState);
    if (v_containerState_val) {
        v_containerState = VAL_STRING(v_containerState_val);
        (void)v_containerState;  /* remove this line if variable used */
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* u_amantya_niab_change_contanier_state_validate */


/**
 * @brief Invocation phase callback for "<change-contanier-state>" operation. (agt_rpc_method_t)
 *
 * Validation callback has passed at this point.
 * Call device instrumentation code in this function.
 *
 * @param scb session invoking the RPC operation.
 * @param msg message in progress for this <rpc> request.
 * The msg->rpc_input value node contains the input (if any).
 * It is a container matching the rpc/input node for the YANG rpc.
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_amantya_niab_change_contanier_state_invoke (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nStart SIL invoke rpc <change-contanier-state> from module Amantya-NIAB-5gsacore");
    }

    val_value_t *inputval = agt_get_rpc_input(msg);
    if (inputval == NULL) return ERR_NCX_OPERATION_FAILED;

    val_value_t *v_containerType_val = NULL;
    const xmlChar *v_containerType = NULL;

    val_value_t *v_containerState_val = NULL;
    const xmlChar *v_containerState = NULL;

    /* RPC Input: containerType */
    v_containerType_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerType);
    if (v_containerType_val) {
        v_containerType = VAL_STRING(v_containerType_val);
        (void)v_containerType;  /* remove this line if variable used */
    }

    /* RPC Input: containerState */
    v_containerState_val = val_find_child(
        inputval,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_containerState);
    if (v_containerState_val) {
        v_containerState = VAL_STRING(v_containerState_val);
        (void)v_containerState;  /* remove this line if variable used */
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */


    /* No output nodes expected */

    return res;

} /* u_amantya_niab_change_contanier_state_invoke */


/**
 * @brief Send a "<updateConfigurtion>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_updateConfigurtion_send (
    const xmlChar *v_fileUpdated)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <updateConfigurtion> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <updateConfigurtion> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(updateConfigurtion_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<updateConfigurtion> notification");
        return;
    }
    
    /* add fileUpdated to payload */
    parmval = agt_make_leaf2(
        updateConfigurtion_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_fileUpdated,
        v_fileUpdated,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'fileUpdated' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_updateConfigurtion_send */


/**
 * @brief Send a "<register-device>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_register_device_send (
    const xmlChar *v_ip_add,
    const xmlChar *v_port,
    const xmlChar *v_user,
    const xmlChar *v_password,
    const xmlChar *v_name,
    const xmlChar *v_type,
    const xmlChar *v_serial,
    const xmlChar *v_manufacturer,
    const xmlChar *v_hw_version,
    const xmlChar *v_sw_version,
    boolean v_is_device_added)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <register-device> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <register-device> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(register_device_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<register-device> notification");
        return;
    }
    
    /* add ip_add to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_ip_add,
        v_ip_add,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'ip_add' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add port to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_port,
        v_port,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'port' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add user to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_user,
        v_user,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'user' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add password to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_password,
        v_password,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'password' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add name to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_name,
        v_name,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'name' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add type to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_type,
        v_type,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'type' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add serial to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_serial,
        v_serial,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'serial' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add manufacturer to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_manufacturer,
        v_manufacturer,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'manufacturer' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add hw_version to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_hw_version,
        v_hw_version,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'hw_version' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add sw_version to payload */
    parmval = agt_make_leaf2(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_sw_version,
        v_sw_version,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'sw_version' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add is_device_added to payload */
    parmval = agt_make_boolean_leaf(
        register_device_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_is_device_added,
        v_is_device_added,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'is_device_added' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_register_device_send */


/**
 * @brief Send a "<niab_containers_amf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_amf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_amf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_amf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_amf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_amf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_amf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_amf_send */


/**
 * @brief Send a "<niab_containers_gnb>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_gnb_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_gnb> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_gnb> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_gnb_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_gnb> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_gnb_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_gnb_send */


/**
 * @brief Send a "<niab_containers_upf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_upf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_upf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_upf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_upf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_upf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_upf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_upf_send */


/**
 * @brief Send a "<niab_containers_smf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_smf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_smf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_smf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_smf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_smf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_smf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_smf_send */


/**
 * @brief Send a "<niab_containers_nrf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_nrf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_nrf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_nrf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_nrf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_nrf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_nrf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_nrf_send */


/**
 * @brief Send a "<niab_containers_ausf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_ausf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_ausf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_ausf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_ausf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_ausf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_ausf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_ausf_send */


/**
 * @brief Send a "<niab_containers_nssf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_nssf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_nssf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_nssf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_nssf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_nssf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_nssf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_nssf_send */


/**
 * @brief Send a "<niab_containers_nef>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_nef_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_nef> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_nef> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_nef_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_nef> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_nef_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_nef_send */


/**
 * @brief Send a "<niab_containers_pcf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_pcf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_pcf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_pcf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_pcf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_pcf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_pcf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_pcf_send */


/**
 * @brief Send a "<niab_containers_af>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_af_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_af> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_af> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_af_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_af> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_af_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_af_send */


/**
 * @brief Send a "<niab_containers_bsf>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_bsf_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_bsf> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_bsf> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_bsf_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_bsf> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_bsf_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_bsf_send */


/**
 * @brief Send a "<niab_containers_udm>" notification.
 *
 * Called by your code when notification event occurs.
 *
 * This API is optional. It can be replaced with
 * any function of your choice that provides the same functionality.
 *
 * Create an internal notification message (agt_not_msg_t) and queue
 * it for delivery to client sessions.
 *
 * The parameters depend in the data definitions within the
 * notification-stmt for this event type.
 */
void u_amantya_niab_niab_containers_udm_send (
    const xmlChar *v_changedState,
    const xmlChar *v_alarmSource,
    const xmlChar *v_timeRaised,
    const xmlChar *v_severity,
    const xmlChar *v_description,
    boolean v_clearAlarm,
    const xmlChar *v_alarmType)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <niab_containers_udm> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <niab_containers_udm> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(niab_containers_udm_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<niab_containers_udm> notification");
        return;
    }
    
    /* add changedState to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_changedState,
        v_changedState,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'changedState' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmSource to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmSource,
        v_alarmSource,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmSource' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add timeRaised to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_timeRaised,
        v_timeRaised,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'timeRaised' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add severity to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_severity,
        v_severity,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'severity' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add description to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_description,
        v_description,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'description' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add clearAlarm to payload */
    parmval = agt_make_boolean_leaf(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_clearAlarm,
        v_clearAlarm,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'clearAlarm' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    /* add alarmType to payload */
    parmval = agt_make_leaf2(
        niab_containers_udm_obj,
        y_amantya_niab_M_amantya_niab,
        y_amantya_niab_N_alarmType,
        v_alarmType,
        &res);
    if (parmval == NULL) {
        log_error("\nError: Cannot add leaf 'alarmType' to payload (%s)",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }

    agt_not_queue_notification(notif);
    
} /* u_amantya_niab_niab_containers_udm_send */


/**
 * @brief Phase 1: Initialize the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
status_t u_Amantya_NIAB_5gsacore_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_Amantya_NIAB_5gsacore_init");
    }

    ncx_module_t *Amantya_NIAB_5gsacore_mod = NULL;

    Amantya_NIAB_5gsacore_mod = ncx_find_module(modname, revision);
    if (Amantya_NIAB_5gsacore_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    updateConfigurtion_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_updateConfigurtion);
    if (updateConfigurtion_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    register_device_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_register_device);
    if (register_device_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_amf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_amf);
    if (niab_containers_amf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_gnb_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_gnb);
    if (niab_containers_gnb_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_upf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_upf);
    if (niab_containers_upf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_smf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_smf);
    if (niab_containers_smf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_nrf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_nrf);
    if (niab_containers_nrf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_ausf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_ausf);
    if (niab_containers_ausf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_nssf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_nssf);
    if (niab_containers_nssf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_nef_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_nef);
    if (niab_containers_nef_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_pcf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_pcf);
    if (niab_containers_pcf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_af_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_af);
    if (niab_containers_af_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_bsf_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_bsf);
    if (niab_containers_bsf_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    niab_containers_udm_obj = ncx_find_object(
        Amantya_NIAB_5gsacore_mod,
        y_amantya_niab_N_niab_containers_udm);
    if (niab_containers_udm_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    /* put your module initialization code here */

    return res;

} /* u_Amantya_NIAB_5gsacore_init */


/**
 * @brief Phase 2: Initialize the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
status_t u_Amantya_NIAB_5gsacore_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_Amantya_NIAB_5gsacore_init2");
    }


    /* put your init2 code here */

    return res;

} /* u_Amantya_NIAB_5gsacore_init2 */


/**
 * @brief Cleanup the Amantya-NIAB-5gsacore server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
void u_Amantya_NIAB_5gsacore_cleanup (void)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_Amantya_NIAB_5gsacore_cleanup");
    }


    /* put your cleanup code here */

} /* u_Amantya_NIAB_5gsacore_cleanup */


 /** @} */

/* END SIL u_Amantya-NIAB-5gsacore.c */
